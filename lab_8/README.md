# Технологии и методы программирования

## Лабораторная работа №8: «Асинхронное программирование»

В рамках данной лабораторной работы требуется продемонстрировать способность к написанию асинхронного кода на python.

## Задание
1. Создать отдельную ветку в своем [форке](https://docs.github.com/en/get-started/quickstart/fork-a-repo) данного репозитория.
2. Написать код приложения, содержащий *осмысленный* асинхронный код, с помощью [материала лекции](https://github.com/xtrueman/prog_instruments/raw/main/presentations/Async.pptx).
6. Открыть [пул-риквест](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork) и ждать ревью.

## Примеры задач по асинхронному программированию (можете придумать свои)

### Crowler по сайтам (забрать метаданные с каждого сайта)
Дан список доменов в формате .CSV (10000 доменов), нужно асинхронно (с помощью любой асинхронной библиотеки поддерживающей HTTP / HTTPS) обратиться к данным сайтам и запросить главную страницу. По каждому домену / сайту обратиться вначале по HTTP затем по HTTPS и получить следующую информацию, следующие поля:
   - http_status — результат обращения на главную страницу по HTTP: код возврата (200, 303 и т.п.), если не удалось установить соединение / получить ответ — None
   - http_server — содержимое заголовка Server в ответе сервера или None если запрос неуспешен
   - http_content_length — длина response body в байтах (может быть 0) или None если запрос неуспешен
   - http_content_language — содержимое заголовка ответа "Content-Language", в виде списка, если этот заголовок есть или пустой список
   - http_cookies — список кук которые нам отдал сервер, если отдал или пустой список
   - https_status — Удалось ли успешно установить соединение, `Ok` если удалось, а если нет — написать ошибку TLS (в любом читаемом формате)
   - https_status, https_server, https_content_length, http_content_language, https_status, https_cookies — всё аналогично соответствующим полям http_*

В запросе указать заголовок Accept-Language: ru-RU!
Всё должно работать полностью асинхронно (включая резолвинг DNS), ограничение — 1000 одновременных соединений.
Итоговый результат положить в файл domain_status в виде JSON — список словарей с указанными выше полями. При этом http_cookies, http_content_language — списки (могут быть пустые списки)

Список сайтов тут: https://github.com/xtrueman/network_programming/blob/main/data/top-10k.csv.gz
Но можете взять любой другой свой список.

### Нагрузочный тестер для сайтов

Написать на python с применением любой библиотеки для асинхронного HTTP/HTTPS скрипт для нагрузочного тестирования сайтов (по HTTP или HTTPS).
На входе (в командной строке или в конфиге):
1. URL сайта, который тестируем, например `https://www.bitrix24.ru/prices/`
2. Количество запросов в секунду (RPS), например `100`
3. Количество секунд, которые тестируем (test_time), например, `10`
4. Таймаут сколько подождать завершения ответов на запросы (wait_timeout) после того как истечёт test_time, например `5`

Нужно равномерно инициировать в течение test_time RPS запросов в секунду, потом подождать test_time секунд. Проанализировать / агрегировать результаты.

Представить итоговый результат например в таком виде:
```
Target URL: https://www.bitrix24.ru/prices/
Test duration: 10s, RPS: 100 (total 1000 requests)
Timeout for responses: 5s

=== Request Summary ===
Total requests sent:    1000
Completed successfully:  845
Failed requests:      155
- Timeout errors:     112
- Connection errors:  31
- HTTP errors (5xx):  12

=== Response Time (ms) ===
Min:     48
Max:   4012
Mean:   523.7
Median: 217
p75:    312
p90:    743
p95:   1031
p99:   2561

=== Status Code Distribution ===
200 OK:         832
301 Redirect:    13
500 Server Err:  10
Timeouts:       112
```
Задание и формат вывода можно видоизменить по вашему выбору.

### Асинхронная скачивалка изображений

Получить список URL-адресов изображений из CSV и асинхронно скачать все изображения в каталог, ограничив одновременные загрузки (например, 20 параллельно).
Особенности: логировать прогресс, обработать ошибки.

### Telegram-userbot с использованием Telethon

Написать юзербот (скрипт, действующий от имени **обычного пользователя** телеграм) с использованем библиотеки telethon.
Юзербот может выполнять любые задачи на ваш выбор, например:
- скачивать в JSON или MD историю любого чата / группового чата, который укажете
- скачивать аудиофайлы / видеофайлы из любого чата
- отправлять определённые сообщения контактам на ваш выбор
- и т.п.

### Асинхронный мониторинг сайтов

Простейший uptime-monitor.
Асинхронно проверять доступность списка сайтов (список задан например в виде CSV файла или в базе или где-то ещё) (по HEAD или GET-запросу), каждые N секунд, и логировать изменение статуса. Проверяем HTTP status.

Если статус сайта изменился с "рабочего" на "нерабочий", например статус с 200 на 502, то отсылаем alert (в виде сообщения в телеграме или SMS или email или в ином виде) на контакт, указанный в CSV-файле.
Сообщение в телеграме можете отправлять например с помощью библиотеки Telethon.

Пример CSV-файла:
```CSV
DOMAIN_NAME;tg_username,email
example.com,@xtrueman22,xtrueman22@gmail.com
mizulina.ru,@mizulina,mizulin


## Ремарки:
Работать с git вы можете так, как вам удобно:
* через интерфейс [командной строки](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git),
* через [плагин](https://www.jetbrains.com/help/pycharm/set-up-a-git-repository.html#fetch) в IDE,
* через десктопный клиент, типа [такого](https://desktop.github.com/).

Если вы столкнулись с непреодолимыми трудностями в ходе выполнения лабораторной работы, вы можете задать вопрос в:
* в виде [ишью](https://github.com/itsecd/prog_instruments_labs/issues/new/choose) в этом репозитории,
* в разделе [Q&A](https://github.com/itsecd/prog_instruments_labs/discussions/categories/q-a) дискуссий в этом репозитории,
* телеграм-чате предмета,
* телеграм-чате вашего курса.
